<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GolangéŸ³é¢‘å¤„ç†ç¤ºä¾‹ - è®¡ç®—æœºéŸ³é¢‘å¤„ç†å­¦ä¹ æŒ‡å— </title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>

    <nav>
        <div class="container">
            <ul>
                <li><a href="index.html">é¦–é¡µ</a></li>
                <li><a href="algorithms.html">å¸¸ç”¨ç®—æ³•</a></li>
                <li><a href="ai-audio.html">AIéŸ³é¢‘å¤„ç†</a></li>
                <li><a href="streaming-protocols.html">åœ¨çº¿éŸ³é¢‘åè®®</a></li>
                <li><a href="python-examples.html">Pythonç¤ºä¾‹</a></li>
                <li><a href="golang-examples.html">Golangç¤ºä¾‹</a></li>
                <li><a href="audio-terms.html">éŸ³é¢‘æœ¯è¯­</a></li>
                <li><a href="ffmpeg-audio.html">FFmpeg å¤„ç†</a></li>
            </ul>
        </div>
    </nav>

    <div class="container">
        <section class="section">
            <h2>ğŸ“¦ ç¯å¢ƒå‡†å¤‡ (ç‰ˆ)</h2>
            
            <div class="content-block">
                <h4>å®‰è£…Golangå’Œç›¸å…³åº“</h4>
                <div class="code-block">
                    <pre><span class="comment"># åˆå§‹åŒ–é¡¹ç›®</span>
go mod init audio-processing-

<span class="comment"># ä¼ ç»ŸéŸ³é¢‘å¤„ç†</span>
go get github.com/mjibson/go-dsp/fft
go get github.com/go-audio/audio
go get github.com/go-audio/wav
go get github.com/go-audio/midi

<span class="comment"># AI/ONNXæ¨ç† (æ¨è)</span>
go get github.com/yourbasic/onnxruntime
go get github.com/second-state/go-onnxruntime
go get github.com/owulveryck/onnx-go

<span class="comment"># å¹¶å‘éŸ³é¢‘å¤„ç†</span>
go get github.com/hashicorp/golang-lru
go get golang.org/x/sync/errgroup
</pre>
                </div>
            </div>

            <div class="info-box">
                <h4>GolangéŸ³é¢‘å¤„ç†ä¼˜åŠ¿ </h4>
                <ul>
                    <li><strong>é«˜æ€§èƒ½</strong>ï¼šç¼–è¯‘å‹è¯­è¨€ï¼Œæ‰§è¡Œæ•ˆç‡é«˜</li>
                    <li><strong>ONNXæ”¯æŒ</strong>ï¼šè·¨å¹³å°AIæ¨¡å‹éƒ¨ç½²</li>
                    <li><strong>NPUåŠ é€Ÿ</strong>ï¼šåˆ©ç”¨ç¡¬ä»¶AIåŠ é€Ÿå™¨</li>
                    <li><strong>å¹¶å‘æ”¯æŒ</strong>ï¼šgoroutineè½»æ¾å¤„ç†å®æ—¶éŸ³é¢‘æµ</li>
                </ul>
            </div>
        </section>

        <section class="section">
            <h2">ğŸ“ ç¤ºä¾‹1ï¼šWAVæ–‡ä»¶AIé¢„å¤„ç†</h2>
            
            <div class="example-section">
                <h3>é«˜æ•ˆWAVæ–‡ä»¶è¯»å†™ä¸AIæ ¼å¼æ”¯æŒ</h3>
                
                <div class="language-tabs">
                    <button class="language-tab golang active" onclick="showCode('golang1')">Golang</button>
                </div>
                
                <div id="golang1" class="code-block">
                    <pre><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"encoding/binary"</span>
    <span class="string">"fmt"</span>
    <span class="string">"os"</span>
    <span class="string">"io"</span>
    <span class="string">"math"</span>
)

<span class="comment">// WAVæ–‡ä»¶å¤´ç»“æ„ (å¢å¼ºç‰ˆ)</span>
<span class="keyword">type</span> WAVHeader <span class="keyword">struct</span> {
    RIFF            [<span class="number">4</span>]<span class="keyword">byte</span>
    FileSize        <span class="keyword">uint32</span>
    WAVE            [<span class="number">4</span>]<span class="keyword">byte</span>
    FMT             [<span class="number">4</span>]<span class="keyword">byte</span>
    ChunkSize       <span class="keyword">uint32</span>
    AudioFormat     <span class="keyword">uint16</span>
    NumChannels     <span class="keyword">uint16</span>
    SampleRate      <span class="keyword">uint32</span>
    ByteRate        <span class="keyword">uint32</span>
    BlockAlign      <span class="keyword">uint16</span>
    BitsPerSample   <span class="keyword">uint16</span>
    ExtensionSize   <span class="keyword">uint16</span>
    ValidBits       <span class="keyword">uint16</span>
    ChannelMask     <span class="keyword">uint32</span>
    SubFormat       [<span class="number">16</span>]<span class="keyword">byte</span>
}

<span class="comment">// AudioData ä¼˜åŒ–çš„éŸ³é¢‘æ•°æ®ç»“æ„</span>
<span class="keyword">type</span> AudioData <span class="keyword">struct</span> {
    Header      WAVHeader
    Samples     []<span class="keyword">float32</span>  <span class="comment">// float32 for AI processing
    SampleRate  <span class="keyword">int</span>
    Duration    <span class="keyword">float64</span>
}

<span class="comment">// ReadWAV è¯»å–WAVæ–‡ä»¶</span>
<span class="keyword">func</span> <span class="function">ReadWAV</span>(filename <span class="keyword">string</span>) (*AudioData, <span class="keyword">error</span>) {
    file, err := os.Open(filename)
    <span class="keyword">if</span> err != <span class="keyword">nil</span> {
        <span class="keyword">return</span> <span class="keyword">nil</span>, err
    }
    <span class="keyword">defer</span> file.Close()

    header := WAVHeader{}
    err = binary.Read(file, binary.LittleEndian, &header)
    <span class="keyword">if</span> err != <span class="keyword">nil</span> {
        <span class="keyword">return</span> <span class="keyword">nil</span>, err
    }

    <span class="comment">// AIä¼˜åŒ–ï¼šä½¿ç”¨float32æé«˜è®¡ç®—æ•ˆç‡</span>
    samples := []<span class="keyword">float32</span>{}
    bytesPerSample := <span class="keyword">int</span>(header.BitsPerSample / <span class="number">8</span>)
    buffer := <span class="keyword">make</span>([]<span class="keyword">byte</span>, bytesPerSample)

    <span class="keyword">for</span> {
        chunkHeader := [<span class="number">4</span>]<span class="keyword">byte</span>{}
        _, err = io.ReadFull(file, chunkHeader[:])
        <span class="keyword">if</span> err == io.EOF {
            <span class="keyword">break</span>
        }

        chunkData := [<span class="number">4</span>]<span class="keyword">byte</span>{}
        binary.Read(file, binary.LittleEndian, &chunkData)
        chunkSize := <span class="keyword">uint32</span>(chunkData[<span class="number">0</span>]) | 
                    <span class="keyword">uint32</span>(chunkData[<span class="number">1</span>])<<<span class="number">8</span> | 
                    <span class="keyword">uint32</span>(chunkData[<span class="number">2</span>])<<<span class="number">16</span> | 
                    <span class="keyword">uint32</span>(chunkData[<span class="number">3</span>])<<<span class="number">24</span>

        chunkName := <span class="keyword">string</span>(chunkHeader[:])

        <span class="keyword">if</span> chunkName == <span class="string">"data"</span> {
            numSamples := <span class="keyword">int</span>(chunkSize) / bytesPerSample
            samples = <span class="keyword">make</span>([]<span class="keyword">float32</span>, numSamples)

            <span class="keyword">for</span> i := <span class="number">0</span>; i < numSamples; i++ {
                _, err = io.ReadFull(file, buffer)
                <span class="keyword">if</span> err != <span class="keyword">nil</span> {
                    <span class="keyword">break</span>
                }

                <span class="keyword">var</span> sample <span class="keyword">float32</span>
                <span class="keyword">switch</span> header.BitsPerSample {
                <span class="keyword">case</span> <span class="number">16</span>:
                    sample = <span class="keyword">float32</span>(<span class="keyword">int16</span>(buffer[<span class="number">0</span>]) | 
                              <span class="keyword">int16</span>(buffer[<span class="number">1</span>])<<<span class="number">8</span>) / <span class="number">32768.0</span>
                <span class="keyword">case</span> <span class="number">24</span>:
                    sample = <span class="keyword">float32</span>(<span class="keyword">int32</span>(buffer[<span class="number">0</span>]) | 
                              <span class="keyword">int32</span>(buffer[<span class="number">1</span>])<<<span class="number">8</span> | 
                              <span class="keyword">int32</span>(buffer[<span class="number">2</span>])<<<span class="number">16</span>) / <span class="number">8388608.0</span>
                <span class="keyword">case</span> <span class="number">32</span>:
                    <span class="keyword">if</span> header.AudioFormat == <span class="number">3</span> {  <span class="comment">// IEEE Float
                        sample = <span class="keyword">float32</span>(math.Float32frombits(
                            <span class="keyword">uint32</span>(buffer[<span class="number">0</span>]) | 
                            <span class="keyword">uint32</span>(buffer[<span class="number">1</span>])<<<span class="number">8</span> | 
                            <span class="keyword">uint32</span>(buffer[<span class="number">2</span>])<<<span class="number">16</span> | 
                            <span class="keyword">uint32</span>(buffer[<span class="number">3</span>])<<<span class="number">24</span>))
                    }
                }
                samples[i] = sample
            }
        } <span class="keyword">else</span> {
            file.Seek(<span class="keyword">int64</span>(chunkSize), <span class="number">1</span>)
        }
    }

    duration := <span class="keyword">float64</span>(len(samples)) / <span class="keyword">float64</span>(header.SampleRate)

    <span class="keyword">return</span> &AudioData{
        Header:     header,
        Samples:    samples,
        SampleRate: <span class="keyword">int</span>(header.SampleRate),
        Duration:   duration,
    }, <span class="keyword">nil</span>
}

<span class="comment">// Normalize å½’ä¸€åŒ–éŸ³é¢‘æ•°æ®ï¼ˆAIé¢„å¤„ç†ï¼‰</span>
<span class="keyword">func</span> (a *AudioData) <span class="function">Normalize</span>() {
    maxAmp := <span class="keyword">float32</span>(<span class="number">0</span>)
    <span class="keyword">for</span> _, sample := <span class="keyword">range</span> a.Samples {
        <span class="keyword">if</span> abs := <span class="keyword">float32</span>(math.Abs(<span class="keyword">float64</span>(sample))); abs > maxAmp {
            maxAmp = abs
        }
    }

    <span class="keyword">if</span> maxAmp > <span class="number">0</span> {
        gain := <span class="number">0.95</span> / maxAmp
        <span class="keyword">for</span> i := <span class="keyword">range</span> a.Samples {
            a.Samples[i] *= gain
        }
    }
}

<span class="comment">// ToMFCC è½¬æ¢ä¸ºMFCCç‰¹å¾ï¼ˆç”¨äºAIå¤„ç†ï¼‰</span>
<span class="keyword">func</span> (a *AudioData) <span class="function">ToMFCC</span>(numCoeffs <span class="keyword">int</span>) ([]<span class="keyword">float64</span>, <span class="keyword">error</span>) {
    <span class="comment">// ç®€åŒ–çš„MFCCè®¡ç®—
    nFFT := <span class="number">512</span>
    hopLength := <span class="number">160</span>
    
    <span class="comment">">// è®¡ç®—çŸ­æ—¶å‚…é‡Œå¶å˜æ¢
    stft := a.computeSTFT(nFFT, hopLength)
    
    <span class="comment">// åº”ç”¨æ¢…å°”æ»¤æ³¢å™¨ç»„
    melFilter := a.createMelFilterBank(nFFT, numCoeffs)
    
    <span class="comment">// è®¡ç®—MFCC
    mfcc := make([]<span class="keyword">float64</span>, numCoeffs)
    <span class="keyword">for</span> i := <span class="number">0</span>; i < numCoeffs; i++ {
        <span class="keyword">var</span> sum <span class="keyword">float64</span>
        <span class="keyword">for</span> j := <span class="number">0</span>; j < len(stft); j++ {
            sum += melFilter[i][j] * stft[j]
        }
        mfcc[i] = math.Log(sum + <span class="number">1e-10</span>)
    }
    
    <span class="keyword">return</span> mfcc, <span class="keyword">nil</span>
}

<span class="comment">// computeSTFT è®¡ç®—çŸ­æ—¶å‚…é‡Œå¶å˜æ¢</span>
<span class="keyword">func</span> (a *AudioData) <span class="function">computeSTFT</span>(nFFT, hopLength <span class="keyword">int</span>) []<span class="keyword">float64</span> {
    <span class="comment">// ç®€åŒ–å®ç°</span>
    numFrames := (len(a.Samples) - nFFT) / hopLength
    spectrum := make([]<span class="keyword">float64</span>, nFFT/<span class="number">2</span>+<span class="number">1</span>)
    
    <span class="comment">// è¿”å›åŠŸç‡è°±
    <span class="keyword">return</span> spectrum
}

<span class="comment">// createMelFilterBank åˆ›å»ºæ¢…å°”æ»¤æ³¢å™¨ç»„</span>
<span class="keyword">func</span> (a *AudioData) <span class="function">createMelFilterBank</span>(nFFT, numFilters <span class="keyword">int</span>) [][]<span class="keyword">float64</span> {
    filterBank := make([][]<span class="keyword">float64</span>, numFilters)
    <span class="keyword">for</span> i := <span class="keyword">range</span> filterBank {
        filterBank[i] = make([]<span class="keyword">float64</span>, nFFT/<span class="number">2</span>+<span class="number">1</span>)
    }
    <span class="keyword">return</span> filterBank
}

<span class="comment">// ç¤ºä¾‹ä½¿ç”¨</span>
<span class="keyword">func</span> main() {
    wav, err := ReadWAV(<span class="string">"audio.wav"</span>)
    <span class="keyword">if</span> err != <span class="keyword">nil</span> {
        fmt.Printf(<span class="string">"Error: %v\n"</span>, err)
        <span class="keyword">return</span>
    }

    fmt.Printf(<span class="string">"Sample Rate: %d Hz\n"</span>, wav.SampleRate)
    fmt.Printf(<span class="string">"Duration: %.2f seconds\n"</span>, wav.Duration)
    fmt.Printf(<span class="string">"Samples: %d\n"</span>, len(wav.Samples))
    
    <span class="comment">// AIé¢„å¤„ç†</span>
    wav.Normalize()
    
    <span class="comment">// æå–MFCCç‰¹å¾</span>
    mfcc, _ := wav.ToMFCC(<span class="number">13</span>)
    fmt.Printf(<span class="string">"MFCC coefficients: %v\n"</span>, mfcc)</pre>
                </div>
            </div>
        </section>

        <section class="section">
            <h2">âš¡ ç¤ºä¾‹2ï¼šONNX AIæ¨¡å‹æ¨ç†</h2>
            
            <div class="example-section">
                <h3>åœ¨Golangä¸­éƒ¨ç½²ONNX AIéŸ³é¢‘æ¨¡å‹</h3>
                
                <div class="language-tabs">
                    <button class="language-tab golang active" onclick="showCode('golang2')">Golang</button>
                </div>
                
                <div id="golang2" class="code-block">
                    <pre><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"os"</span>
    
    onnxruntime <span class="string">"github.com/yourbasic/onnxruntime"</span>
)

<span class="comment">// ONNXInference ONNXæ¨¡å‹æ¨ç†å¼•æ“ </span>
<span class="keyword">type</span> ONNXInference <span class="keyword">struct</span> {
    session    *onnxruntime.Session
    inputName  <span class="keyword">string</span>
    outputName <span class="keyword">string</span>
}

<span class="keyword">func</span> <span class="function">NewONNXInference</span>(modelPath <span class="keyword">string</span>, providers []<span class="keyword">string</span>) (*ONNXInference, <span class="keyword">error</span>) {
    <span class="comment">// åŠ è½½ONNXæ¨¡å‹</span>
    session, err := onnxruntime.NewSession(modelPath, &onnxruntime.SessionOptions{
        Providers: providers,  <span class="comment">// ["CUDA", "CPU"] or ["CoreML", "NPU"]
    })
    <span class="keyword">if</span> err != <span class="keyword">nil</span> {
        <span class="keyword">return</span> <span class="keyword">nil</span>, fmt.Errorf(<span class="string">"failed to load model: %w"</span>, err)
    }

    <span class="comment">// è·å–è¾“å…¥è¾“å‡ºåç§°</span>
    inputName := session.GetInputNames()[<span class="number">0</span>]
    outputName := session.GetOutputNames()[<span class="number">0</span>]

    <span class="keyword">return</span> &ONNXInference{
        session:    session,
        inputName:  inputName,
        outputName: outputName,
    }, <span class="keyword">nil</span>
}

<span class="comment">// Inference æ‰§è¡Œæ¨ç†</span>
<span class="keyword">func</span> (o *ONNXInference) <span class="function">Inference</span>(input []<span class="keyword">float32</span>) ([]<span class="keyword">float32</span>, <span class="keyword">error</span>) {
    <span class="comment">// å‡†å¤‡è¾“å…¥</span>
    inputTensor := onnxruntime.NewTensor(input, []<span class="keyword">int64</span>{<span class="number">1</span>, <span class="number">16000</span>})

    <span class="comment">// è¿è¡Œæ¨ç†</span>
    outputs, err := o.session.Run([]onnxruntime.Tensor{inputTensor})
    <span class="keyword">if</span> err != <span class="keyword">nil</span> {
        <span class="keyword">return</span> <span class="keyword">nil</span>, err
    }

    <span class="comment">// è·å–è¾“å‡º</span>
    output := outputs[<span class="number">0</span>].(<span class="keyword">*</span>onnxruntime.Tensor).Data().([]<span class="keyword">float32</span>)

    <span class="keyword">return</span> output, <span class="keyword">nil</span>
}

<span class="comment">// AudioClassifier éŸ³é¢‘åˆ†ç±»å™¨ </span>
<span class="keyword">type</span> AudioClassifier <span class="keyword">struct</span> {
    inference *ONNXInference
    classes   []<span class="keyword">string</span>
}

<span class="keyword">func</span> <span class="function">NewAudioClassifier</span>(modelPath <span class="keyword">string</span>, classesPath <span class="keyword">string</span>) (*AudioClassifier, <span class="keyword">error</span>) {
    inference, err := NewONNXInference(modelPath, []<span class="keyword">string</span>{
        <span class="string">"CUDAExecutionProvider"</span>,
        <span class="string">"CPUExecutionProvider"</span>,
    })
    <span class="keyword">if</span> err != <span class="keyword">nil</span> {
        <span class="keyword">return</span> <span class="keyword">nil</span>, err
    }

    <span class="comment">// åŠ è½½ç±»åˆ«æ ‡ç­¾</span>
    classes, err := os.ReadFile(classesPath)
    <span class="keyword">if</span> err != <span class="keyword">nil</span> {
        <span class="keyword">return</span> <span class="keyword">nil</span>, err
    }

    <span class="keyword">return</span> &AudioClassifier{
        inference: inference,
        classes:   <span class="keyword">string</span>s.Fields(<span class="keyword">string</span>(classes)),
    }, <span class="keyword">nil</span>
}

<span class="comment">// Predict é¢„æµ‹éŸ³é¢‘ç±»åˆ«</span>
<span class="keyword">func</span> (c *AudioClassifier) <span class="function">Predict</span>(audioFeatures []<span class="keyword">float32</span>) (string, <span class="keyword">float32</span>) {
    output, err := c.inference.Inference(audioFeatures)
    <span class="keyword">if</span> err != <span class="keyword">nil</span> {
        <span class="keyword">return</span> <span class="string">"error"</span>, <span class="number">0</span>
    }

    <span class="comment">// æ‰¾åˆ°æœ€å¤§æ¦‚ç‡çš„ç±»åˆ«</span>
    maxIdx := <span class="number">0</span>
    maxProb := <span class="keyword">float32</span>(<span class="number">0</span>)
    <span class="keyword">for</span> i, prob := <span class="keyword">range</span> output {
        <span class="keyword">if</span> prob > maxProb {
            maxProb = prob
            maxIdx = i
        }
    }

    <span class="keyword">return</span> c.classes[maxIdx], maxProb
}

<span class="comment">// ä½¿ç”¨ç¤ºä¾‹</span>
<span class="keyword">func</span> main() {
    <span class="comment">// åˆ›å»ºåˆ†ç±»å™¨</span>
    classifier, err := NewAudioClassifier(
        <span class="string">"audio_classifier.onnx"</span>,
        <span class="string">"classes.txt"</span>,
    )
    <span class="keyword">if</span> err != <span class="keyword">nil</span> {
        fmt.Printf(<span class="string">"Error: %v\n"</span>, err)
        <span class="keyword">return</span>
    }

    <span class="comment">// å‡†å¤‡ç‰¹å¾ï¼ˆç¤ºä¾‹ï¼šMFCCç‰¹å¾ï¼‰</span>
    features := make([]<span class="keyword">float32</span>, <span class="number">16000</span>)
    <span class="comment">// å¡«å……ç‰¹å¾...

    <span class="comment">// é¢„æµ‹</span>
    label, confidence := classifier.Predict(features)
    fmt.Printf(<span class="string">"Predicted: %s (confidence: %.2f%%)\n"</span>, label, confidence*<span class="number">100</span>)</pre>
                </div>
            </div>
        </section>

        <section class="section">
            <h2">ğŸ›ï¸ ç¤ºä¾‹3ï¼šå®æ—¶AIéŸ³é¢‘å¤„ç†ç®¡é“</h2>
            
            <div class="example-section">
                <h3>é«˜å¹¶å‘å®æ—¶éŸ³é¢‘AIå¤„ç†</h3>
                
                <div class="language-tabs">
                    <button class="language-tab golang active" onclick="showCode('golang3')">Golang</button>
                </div>
                
                <div id="golang3" class="code-block">
                    <pre><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"context"</span>
    <span class="string">"fmt"</span>
    <span class="string">"sync"</span>
    <span class="string">"time"</span>
    
    <span class="string">"golang.org/x/sync/errgroup"</span>
)

<span class="comment">// AudioProcessor å®æ—¶éŸ³é¢‘å¤„ç†å™¨ </span>
<span class="keyword">type</span> AudioProcessor <span class="keyword">struct</span> {
    sampleRate     <span class="keyword">int</span>
    chunkSize      <span class="keyword">int</span>
    numWorkers     <span class="keyword">int</span>
    inferenceEngine *ONNXInference
    audioBuffer    *AudioBuffer
    wg             sync.WaitGroup
    ctx            context.Context
    cancel         context.CancelFunc
}

<span class="keyword">func</span> <span class="function">NewAudioProcessor</span>(sampleRate, chunkSize, numWorkers <span class="keyword">int</span>) *AudioProcessor {
    ctx, cancel := context.WithCancel(context.Background())
    
    <span class="keyword">return</span> &AudioProcessor{
        sampleRate:     sampleRate,
        chunkSize:      chunkSize,
        numWorkers:     numWorkers,
        audioBuffer:    NewAudioBuffer(chunkSize * <span class="number">10</span>),  <span class="comment">// 10å—ç¼“å­˜
        wg:             sync.WaitGroup{},
        ctx:            ctx,
        cancel:         cancel,
    }
}

<span class="comment">// SetInferenceEngine è®¾ç½®AIæ¨ç†å¼•æ“</span>
<span class="keyword">func</span> (p *AudioProcessor) <span class="function">SetInferenceEngine</span>(engine *ONNXInference) {
    p.inferenceEngine = engine
}

<span class="comment">// AudioBuffer çº¿ç¨‹å®‰å…¨çš„éŸ³é¢‘ç¼“å†²åŒº</span>
<span class="keyword">type</span> AudioBuffer <span class="keyword">struct</span> {
    data     []<span class="keyword">float32</span>
    writePos <span class="keyword">int</span>
    readPos  <span class="keyword">int</span>
    mu       sync.RWMutex
    cond     *sync.Cond
}

<span class="keyword">func</span> <span class="function">NewAudioBuffer</span>(size <span class="keyword">int</span>) *AudioBuffer {
    buf := &AudioBuffer{
        data: make([]<span class="keyword">float32</span>, size),
    }
    buf.cond = sync.NewCond(buf.mu.RLocker())
    <span class="keyword">return</span> buf
}

<span class="comment">// Write å†™å…¥éŸ³é¢‘æ•°æ®</span>
<span class="keyword">func</span> (b *AudioBuffer) <span class="function">Write</span>(data []<span class="keyword">float32</span>) {
    b.mu.Lock()
    <span class="keyword">defer</span> b.mu.Unlock()

    <span class="keyword">for</span> _, sample := <span class="keyword">range</span> data {
        b.data[b.writePos] = sample
        b.writePos = (b.writePos + <span class="number">1</span>) % len(b.data)
        <span class="keyword">if</span> b.writePos == b.readPos {
            <span class="comment">// ç¼“å†²åŒºæ»¡ï¼Œè·³è¿‡æœ€æ—§çš„æ•°æ®
            b.readPos = (b.readPos + <span class="number">1</span>) % len(b.data)
        }
    }
    b.cond.Broadcast()
}

<span class="comment">// Read è¯»å–éŸ³é¢‘æ•°æ®</span>
<span class="keyword">func</span> (b *AudioBuffer) <span class="function">Read</span>(size <span class="keyword">int</span>) []<span class="keyword">float32</span> {
    b.mu.RLock()
    <span class="keyword">defer</span> b.mu.RUnlock()

    <span class="keyword">for</span> b.available() < size {
        b.cond.Wait()
    }

    result := make([]<span class="keyword">float32</span>, size)
    <span class="keyword">for</span> i := <span class="number">0</span>; i < size; i++ {
        result[i] = b.data[b.readPos]
        b.readPos = (b.readPos + <span class="number">1</span>) % len(b.data)
    }
    <span class="keyword">return</span> result
}

<span class="comment">// available è¿”å›å¯ç”¨æ ·æœ¬æ•°</span>
<span class="keyword">func</span> (b *AudioBuffer) <span class="function">available</span>() <span class="keyword">int</span> {
    <span class="keyword">if</span> b.writePos >= b.readPos {
        <span class="keyword">return</span> b.writePos - b.readPos
    }
    <span class="keyword">return</span> len(b.data) - b.readPos + b.writePos
}

<span class="comment">// ProcessorWorker å¤„ç†å·¥ä½œåç¨‹</span>
<span class="keyword">func</span> (p *AudioProcessor) <span class="function">ProcessorWorker</span>(id <span class="keyword">int</span>) {
    <span class="keyword">defer</span> p.wg.Done()

    <span class="keyword">for</span> {
        <span class="keyword">select</span> {
        <span class="keyword">case</span> <-p.ctx.Done():
            <span class="keyword">return</span>
        <span class="keyword">default</span>:
            <span class="comment">// è¯»å–éŸ³é¢‘å—</span>
            chunk := p.audioBuffer.Read(p.chunkSize)

            <span class="comment">// åº”ç”¨AIå¤„ç†
            <span class="keyword">if</span> p.inferenceEngine != <span class="keyword">nil</span> {
                result, err := p.inferenceEngine.Inference(chunk)
                <span class="keyword">if</span> err != <span class="keyword">nil</span> {
                    <span class="comment">// å¤„ç†é”™è¯¯
                    continue
                }
                <span class="comment">// è¾“å‡ºå¤„ç†ç»“æœ
                _ = result
            }
        }
    }
}

<span class="comment">// Start å¯åŠ¨å¤„ç†å™¨</span>
<span class="keyword">func</span> (p *AudioProcessor) <span class="function">Start</span>() {
    <span class="keyword">for</span> i := <span class="number">0</span>; i < p.numWorkers; i++ {
        p.wg.Add(<span class="number">1</span>)
        <span class="keyword">go</span> p.ProcessorWorker(i)
    }
}

<span class="comment">// Stop åœæ­¢å¤„ç†å™¨</span>
<span class="keyword">func</span> (p *AudioProcessor) <span class="function">Stop</span>() {
    p.cancel()
    p.wg.Wait()
}

<span class="comment">// Benchmark æ€§èƒ½æµ‹è¯•</span>
<span class="keyword">func</span> (p *AudioProcessor) <span class="function">Benchmark</span>(duration <span class="keyword">time.Duration</span>) {
    p.Start()
    
    start := time.Now()
    count := <span class="number">0</span>
    
    <span class="keyword">go</span> <span class="keyword">func</span>() {
        <span class="keyword">for</span> time.Since(start) < duration {
            <span class="comment">// ç”Ÿæˆæµ‹è¯•æ•°æ®</span>
            testData := make([]<span class="keyword">float32</span>, p.chunkSize)
            <span class="keyword">for</span> i := <span class="keyword">range</span> testData {
                testData[i] = <span class="keyword">float32</span>(i%<span class="number">256</span>) / <span class="number">256.0</span>
            }
            p.audioBuffer.Write(testData)
            count++
            time.Sleep(time.Millisecond)
        }
    }()
    
    <span class="keyword">select</span> {
    <span class="keyword">case</span> <-time.After(duration + time.Second):
    }
    
    p.Stop()
    
    throughput := <span class="keyword">float64</span>(count) / duration.Seconds()
    fmt.Printf(<span class="string">"Processed %.2f chunks/second\n"</span>, throughput)
}

<span class="comment">// ä½¿ç”¨ç¤ºä¾‹</span>
<span class="keyword">func</span> main() {
    <span class="comment">// åˆ›å»ºå¤„ç†å™¨ (16kHzé‡‡æ ·ç‡, 160æ ·æœ¬/å—, 4åç¨‹)</span>
    processor := NewAudioProcessor(<span class="number">16000</span>, <span class="number">160</span>, <span class="number">4</span>)

    <span class="comment">// åŠ è½½AIæ¨¡å‹
    inference, err := NewONNXInference(<span class="string">"denoiser.onnx"</span>, []<span class="keyword">string</span>{
        <span class="string">"CUDAExecutionProvider"</span>,
        <span class="string">"CPUExecutionProvider"</span>,
    })
    <span class="keyword">if</span> err != <span class="keyword">nil</span> {
        fmt.Printf(<span class="string">"Error: %v\n"</span>, err)
        <span class="keyword">return</span>
    }
    processor.SetInferenceEngine(inference)

    <span class="comment">// æ€§èƒ½æµ‹è¯•</span>
    processor.Benchmark(<span class="number">10</span> * time.Second)</pre>
                </div>
            </div>
        </section>

        <section class="section">
            <h2">ğŸµ ç¤ºä¾‹4ï¼šéŸ³é¢‘AIç‰¹æ•ˆ</h2>
            
            <div class="example-section">
                <h3>AIé©±åŠ¨çš„éŸ³é¢‘æ•ˆæœå¤„ç†</h3>
                
                <div class="language-tabs">
                    <button class="language-tab golang active" onclick="showCode('golang4')">Golang</button>
                </div>
                
                <div id="golang4" class="code-block">
                    <pre><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"math"</span>
)

<span class="comment">// AIEffectsProcessor AIéŸ³é¢‘æ•ˆæœå¤„ç†å™¨ </span>
<span class="keyword">type</span> AIEffectsProcessor <span class="keyword">struct</span> {
    sampleRate    <span class="keyword">int</span>
    effects       []AudioEffect
}

<span class="comment">// AudioEffect éŸ³é¢‘æ•ˆæœæ¥å£</span>
<span class="keyword">type</span> AudioEffect <span class="keyword">interface</span> {
    Process(samples []<span class="keyword">float32</span>) []<span class="keyword">float32</span>
    Reset()
}

<span class="comment">// AIReverb AIå¢å¼ºæ··å“æ•ˆæœ</span>
<span class="keyword">type</span> AIReverb <span class="keyword">struct</span> {
    sampleRate    <span class="keyword">int</span>
    wetMix        <span class="keyword">float32</span>
    dryMix        <span class="keyword">float32</span>
    decay         <span class="keyword">float32</span>
    combFilters   []CombFilter
    allpassFilters []AllpassFilter
}

<span class="comment">// CombFilter æ¢³çŠ¶æ»¤æ³¢å™¨</span>
<span class="keyword">type</span> CombFilter <span class="keyword">struct</span> {
    delayLine []<span class="keyword">float32</span>
    index     <span class="keyword">int</span>
    gain      <span class="keyword">float32</span>
}

<span class="keyword">func</span> <span class="function">NewCombFilter</span>(delaySamples <span class="keyword">int</span>, decay <span class="keyword">float32</span>) *CombFilter {
    <span class="keyword">return</span> &CombFilter{
        delayLine: make([]<span class="keyword">float32</span>, delaySamples),
        gain:      decay,
    }
}

<span class="keyword">func</span> (c *CombFilter) <span class="function">Process</span>(input <span class="keyword">float32</span>) <span class="keyword">float32</span> {
    output := c.delayLine[c.index]
    c.delayLine[c.index] = input + output*c.gain
    c.index = (c.index + <span class="number">1</span>) % len(c.delayLine)
    <span class="keyword">return</span> output
}

<span class="comment">// AllpassFilter å…¨é€šæ»¤æ³¢å™¨</span>
<span class="keyword">type</span> AllpassFilter <span class="keyword">struct</span> {
    delayLine []<span class="keyword">float32</span>
    index     <span class="keyword">int</span>
    gain      <span class="keyword">float32</span>
}

<span class="keyword">func</span> <span class="function">NewAllpassFilter</span>(delaySamples <span class="keyword">int</span>, gain <span class="keyword">float32</span>) *AllpassFilter {
    <span class="keyword">return</span> &AllpassFilter{
        delayLine: make([]<span class="keyword">float32</span>, delaySamples),
        gain:      gain,
    }
}

<span class="keyword">func</span> (a *AllpassFilter) <span class="function">Process</span>(input <span class="keyword">float32</span>) <span class="keyword">float32</span> {
    delayed := a.delayLine[a.index]
    output := delayed + a.gain*input
    a.delayLine[a.index] = input + delayed*a.gain
    a.index = (a.index + <span class="number">1</span>) % len(a.delayLine)
    <span class="keyword">return</span> output
}

<span class="keyword">func</span> <span class="function">NewAIReverb</span>(sampleRate <span class="keyword">int</span>) *AIReverb {
    <span class="comment">// ä¼˜åŒ–çš„æ¢³çŠ¶æ»¤æ³¢å™¨å‚æ•°</span>
    combDelays := []<span class="keyword">int</span>{<span class="number">1116</span>, <span class="number">1188</span>, <span class="number">1277</span>, <span class="number">1356</span>, <span class="number">1492</span>, <span class="number">1617</span>}
    combGains := []<span class="keyword">float32</span>{<span class="number">0.7</span>, <span class="number">0.65</span>, <span class="number">0.6</span>, <span class="number">0.55</span>, <span class="number">0.5</span>, <span class="number">0.45</span>}
    
    combFilters := make([]CombFilter, len(combDelays))
    <span class="keyword">for</span> i := <span class="number">0</span>; i < len(combDelays); i++ {
        combFilters[i] = *NewCombFilter(combDelays[i], combGains[i])
    }
    
    <span class="comment">// å…¨é€šæ»¤æ³¢å™¨</span>
    allpassFilters := make([]AllpassFilter, <span class="number">2</span>)
    allpassFilters[<span class="number">0</span>] = *NewAllpassFilter(<span class="number">556</span>, <span class="number">0.7</span>)
    allpassFilters[<span class="number">1</span>] = *NewAllpassFilter(<span class="number">441</span>, <span class="number">0.5</span>)

    <span class="keyword">return</span> &AIReverb{
        sampleRate:     sampleRate,
        wetMix:        <span class="number">0.3</span>,
        dryMix:        <span class="number">0.7</span>,
        decay:         <span class="number">0.98</span>,
        combFilters:   combFilters,
        allpassFilters: allpassFilters,
    }
}

<span class="keyword">func</span> (r *AIReverb) <span class="function">Process</span>(samples []<span class="keyword">float32</span>) []<span class="keyword">float32</span> {
    output := make([]<span class="keyword">float32</span>, len(samples))

    <span class="keyword">for</span> i := <span class="number">0</span>; i < len(samples); i++ {
        dry := samples[i] * r.dryMix

        <span class="comment">// æ¢³çŠ¶æ»¤æ³¢å™¨</span>
        var wet <span class="keyword">float32</span>
        <span class="keyword">for</span> j := <span class="number">0</span>; j < len(r.combFilters); j++ {
            wet += r.combFilters[j].Process(samples[i])
        }
        wet /= <span class="keyword">float32</span>(len(r.combFilters))

        <span class="comment">// å…¨é€šæ»¤æ³¢å™¨</span>
        <span class="keyword">for</span> j := <span class="number">0</span>; j < len(r.allpassFilters); j++ {
            wet = r.allpassFilters[j].Process(wet)
        }

        wet *= r.wetMix * r.decay
        output[i] = dry + wet
    }

    <span class="keyword">return</span> output
}

<span class="keyword">func</span> (r *AIReverb) <span class="function">Reset</span>() {
    <span class="keyword">for</span> i := <span class="number">0</span>; i < len(r.combFilters); i++ {
        r.combFilters[i].delayLine = make([]<span class="keyword">float32</span>, len(r.combFilters[i].delayLine))
        r.combFilters[i].index = <span class="number">0</span>
    }
    <span class="keyword">for</span> i := <span class="number">0</span>; i < len(r.allpassFilters); i++ {
        r.allpassFilters[i].delayLine = make([]<span class="keyword">float32</span>, len(r.allpassFilters[i].delayLine))
        r.allpassFilters[i].index = <span class="number">0</span>
    }
}

<span class="comment">// AIDelay AIæ™ºèƒ½å»¶è¿Ÿæ•ˆæœ</span>
<span class="keyword">type</span> AIDelay <span class="keyword">struct</span> {
    sampleRate    <span class="keyword">int</span>
    delayTime     <span class="keyword">float32</span>
    feedback      <span class="keyword">float32</span>
    wetMix        <span class="keyword">float32</span>
    dryMix        <span class="keyword">float32</span>
    delayLine     []<span class="keyword">float32</span>
    index         <span class="keyword">int</span>
}

<span class="keyword">func</span> <span class="function">NewAIDelay</span>(sampleRate <span class="keyword">int</span>, delayTime, feedback <span class="keyword">float32</span>) *AIDelay {
    delaySamples := <span class="keyword">int</span>(delayTime * <span class="keyword">float32</span>(sampleRate))
    
    <span class="keyword">return</span> &AIDelay{
        sampleRate:  sampleRate,
        delayTime:   delayTime,
        feedback:    feedback,
        wetMix:      <span class="number">0.4</span>,
        dryMix:      <span class="number">0.6</span>,
        delayLine:   make([]<span class="keyword">float32</span>, delaySamples+<span class="number">1</span>),
    }
}

<span class="keyword">func</span> (d *AIDelay) <span class="function">Process</span>(samples []<span class="keyword">float32</span>) []<span class="keyword">float32</span> {
    output := make([]<span class="keyword">float32</span>, len(samples))

    <span class="keyword">for</span> i := <span class="number">0</span>; i < len(samples); i++ {
        delayed := d.delayLine[d.index]
        output[i] = samples[i]*d.dryMix + delayed*d.wetMix
        d.delayLine[d.index] = samples[i] + delayed*d.feedback
        d.index = (d.index + <span class="number">1</span>) % len(d.delayLine)
    }

    <span class="keyword">return</span> output
}

<span class="comment">// ä½¿ç”¨ç¤ºä¾‹</span>
<span class="keyword">func</span> main() {
    sampleRate := <span class="number">44100</span>

    <span class="comment">// åˆ›å»ºAIæ··å“</span>
    reverb := NewAIReverb(sampleRate)

    <span class="comment">// åˆ›å»ºAIå»¶è¿Ÿ</span>
    delay := NewAIDelay(sampleRate, <span class="number">0.3</span>, <span class="number">0.5</span>)

    <span class="comment">// ç”Ÿæˆæµ‹è¯•ä¿¡å·</span>
    testSignal := make([]<span class="keyword">float32</span>, sampleRate)  <span class="comment">// 1ç§’
    <span class="keyword">for</span> i := <span class="number">0</span>; i < len(testSignal); i++ {
        t := <span class="keyword">float32</span>(i) / <span class="keyword">float32</span>(sampleRate)
        testSignal[i] = <span class="number">0.5</span>*<span class="keyword">float32</span>(math.Sin(<span class="number">2</span>*math.Pi*<span class="number">440</span>*t)) +
                        <span class="number">0.3</span>*<span class="keyword">float32</span>(math.Sin(<span class="number">2</span>*math.Pi*<span class="number">880</span>*t))
    }

    <span class="comment">// åº”ç”¨æ•ˆæœ</span>
    reverbOutput := reverb.Process(testSignal)
    delayOutput := delay.Process(testSignal)

    fmt.Printf(<span class="string">"Original: %d samples\n"</span>, len(testSignal))
    fmt.Printf(<span class="string">"Reverb: %d samples\n"</span>, len(reverbOutput))
    fmt.Printf(<span class="string">"Delay: %d samples\n"</span>, len(delayOutput))
}</pre>
                </div>
            </div>
        </section>
    </div>


    <a href="#" class="back-to-top">â†‘ è¿”å›é¡¶éƒ¨</a>
</body>
</html>
